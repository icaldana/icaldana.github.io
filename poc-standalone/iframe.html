<!DOCTYPE html>
<html lang="pt-BR">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebAuthn Handler</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            text-align: center;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        .iframe-container {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 30px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            max-width: 400px;
            width: 100%;
        }

        .status {
            margin: 10px 0;
            padding: 10px;
            border-radius: 5px;
            font-weight: 500;
        }

        .status.info {
            background: rgba(52, 152, 219, 0.3);
            border: 1px solid rgba(52, 152, 219, 0.5);
        }

        .status.success {
            background: rgba(46, 204, 113, 0.3);
            border: 1px solid rgba(46, 204, 113, 0.5);
        }

        .status.error {
            background: rgba(231, 76, 60, 0.3);
            border: 1px solid rgba(231, 76, 60, 0.5);
        }

        .logs {
            text-align: left;
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            margin-top: 20px;
            max-height: 200px;
            overflow-y: auto;
        }

        .log-entry {
            margin-bottom: 5px;
            opacity: 0.9;
        }

        .timestamp {
            color: #bdc3c7;
            font-size: 10px;
        }
    </style>
</head>

<body>
    <div class="iframe-container">
        <h2>üîê WebAuthn Simplified</h2>
        <p>Authentication + Token</p>

        <div id="status" class="status info">
            Waiting for authentication request...
        </div>

        <div id="logs" class="logs">
            <div class="log-entry">
                <span class="timestamp">[IFRAME]</span> Iframe loaded and ready
            </div>
        </div>
    </div>

    <script>
        // auth-passkey-frontend service configuration
        const AUTH_PASSKEY_CONFIG = {
            baseUrl: 'https://auth-passkey-frontend.sandbox.melioffice.com',
            timeout: 60000
        };

        class FidoIframeHandler {
            constructor() {
                this.port = null;
                this.logs = document.getElementById('logs');
                this.status = document.getElementById('status');

                this.setupMessageListener();
                this.log('üöÄ WebAuthn iframe ready');
            }

            setupMessageListener() {
                window.addEventListener('message', (event) => {
                    const { message, data } = event.data;

                    if (message === 'authenticate') {
                        this.log('üöÄ Starting authentication');
                        this.handleAuthenticationRequest(data, event.ports[0]);
                    }
                });
            }

            async handleAuthenticationRequest(data, port) {
                this.port = port;
                this.transactionId = data.transactionId;
                this.log(`‚úÖ TX ID: ${data.transactionId}`);

                this.updateStatus('Preparing authentication...', 'info');

                // Notify that we are ready
                this.sendMessage('ready', { timestamp: Date.now() });

                // Execute WebAuthn
                setTimeout(() => {
                    this.executeWebAuthn();
                }, 1000);
            }

            async executeWebAuthn() {
                this.updateStatus('Waiting for biometric authentication...', 'info');

                try {
                    // Check WebAuthn support
                    if (!this.isWebAuthnSupported()) {
                        throw new Error('WebAuthn is not supported on this device');
                    }

                    // Execute real WebAuthn
                    const credential = await this.tryRealWebAuthn();
                    this.log(`‚úÖ Credential obtained: ${credential.id}`);

                    // Success! Use credential.id as security token
                    this.handleSuccess(credential, credential.id);

                } catch (error) {
                    this.log(`‚ùå Authentication error: ${error.message}`);
                    this.handleError({
                        message: error.message,
                        retriable: false,
                        cause: 'WEBAUTHN_ERROR'
                    });
                }
            }

            isWebAuthnSupported() {
                return 'credentials' in navigator && 'get' in navigator.credentials;
            }

            async tryRealWebAuthn() {
                try {
                    // ‚úÖ STEP 1: Get real challenge from auth-passkey-frontend
                    this.log('üîó Getting challenge from auth-passkey-frontend...');
                    this.updateStatus('Connecting to authentication service...', 'info');

                    const challengeResponse = await fetch(`${AUTH_PASSKEY_CONFIG.baseUrl}/passkey/validation/start?transaction_id=${this.transactionId}`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            transactionId: this.transactionId,
                            validationType: 'PAYMENT_FLOW'
                        })
                    });

                    if (!challengeResponse.ok) {
                        throw new Error(`Error getting challenge: ${challengeResponse.status} ${challengeResponse.statusText}`);
                    }

                    const challengeData = await challengeResponse.json();
                    this.log('‚úÖ Challenge obtained from backend');

                    const { publicKeyCredentialRequestOptions } = challengeData;

                    if (!publicKeyCredentialRequestOptions) {
                        throw new Error('Invalid challenge returned by server');
                    }

                    this.updateStatus('üëÜ Touch biometric sensor or use your passkey', 'info');
                    this.log('üîê Executing WebAuthn with real challenge...');

                    // Convert challenge from base64 to Uint8Array if needed
                    if (typeof publicKeyCredentialRequestOptions.challenge === 'string') {
                        publicKeyCredentialRequestOptions.challenge = Uint8Array.from(
                            atob(publicKeyCredentialRequestOptions.challenge),
                            c => c.charCodeAt(0)
                        );
                    }

                    const credential = await navigator.credentials.get({
                        publicKey: publicKeyCredentialRequestOptions
                    });

                    if (!credential) {
                        throw new Error('No credential returned');
                    }

                    this.log('‚úÖ WebAuthn credential obtained');

                    // ‚úÖ STEP 3: Send signed credential to backend
                    this.updateStatus('Validating credential on backend...', 'info');
                    this.log('üì§ Sending credential for validation...');

                    const finishResponse = await fetch(`${AUTH_PASSKEY_CONFIG.baseUrl}/passkey/validation/finish?transaction_id=${this.transactionId}`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            id: credential.id,
                            type: credential.type,
                            rawId: btoa(String.fromCharCode(...new Uint8Array(credential.rawId))),
                            response: {
                                authenticatorData: btoa(String.fromCharCode(...new Uint8Array(credential.response.authenticatorData))),
                                clientDataJSON: btoa(String.fromCharCode(...new Uint8Array(credential.response.clientDataJSON))),
                                signature: btoa(String.fromCharCode(...new Uint8Array(credential.response.signature))),
                                userHandle: credential.response.userHandle ? btoa(String.fromCharCode(...new Uint8Array(credential.response.userHandle))) : null
                            }
                        })
                    });

                    if (!finishResponse.ok) {
                        throw new Error(`Validation error: ${finishResponse.status} ${finishResponse.statusText}`);
                    }

                    const finishData = await finishResponse.json();
                    this.log('‚úÖ Validation completed by backend');

                    // ‚úÖ STEP 4: Return transactionCode obtained from Factors
                    const { transactionCode } = finishData;

                    if (!transactionCode) {
                        throw new Error('Transaction code not returned by server');
                    }

                    return {
                        id: transactionCode,
                        type: credential.type,
                        response: credential.response
                    };

                } catch (error) {
                    this.log(`‚ùå WebAuthn flow error: ${error.message}`);

                    if (error.name === 'NotAllowedError') {
                        throw new Error('User cancelled or did not authorize the operation');
                    } else if (error.name === 'InvalidStateError') {
                        throw new Error('No passkey available on this device');
                    } else if (error.name === 'TypeError' && error.message.includes('fetch')) {
                        throw new Error('Connection error with authentication service');
                    } else {
                        throw new Error(`WebAuthn error: ${error.message}`);
                    }
                }
            }

            handleSuccess(credential, securityToken = null) {
                this.log('‚úÖ Authentication successful');
                this.updateStatus('‚úÖ Authentication completed successfully!', 'success');

                const responseData = {
                    token: credential.id,
                    securityToken: securityToken || credential.id,
                    sessionId: `session_${Date.now()}`,
                    credentialId: credential.id,
                    authenticatorData: credential.response.authenticatorData,
                    timestamp: new Date().toISOString()
                };

                this.sendMessage('authenticate', responseData);
                this.log(`üé´ Token: ${responseData.securityToken.substring(0, 30)}...`);
            }

            handleError(error) {
                this.log(`‚ùå Error: ${error.message}`);
                this.updateStatus(`‚ùå Error: ${error.message}`, 'error');
                this.sendMessage('error', { error });
            }

            sendMessage(message, data) {
                if (this.port) {
                    this.port.postMessage({ message, data });
                } else {
                    this.log('‚ö†Ô∏è No port available');
                }
            }

            updateStatus(message, type) {
                this.status.textContent = message;
                this.status.className = `status ${type}`;
            }

            log(message) {
                const timestamp = new Date().toLocaleTimeString();
                const logEntry = document.createElement('div');
                logEntry.className = 'log-entry';
                logEntry.innerHTML = `<span class="timestamp">[${timestamp}]</span> ${message}`;

                this.logs.appendChild(logEntry);
                this.logs.scrollTop = this.logs.scrollHeight;

                while (this.logs.children.length > 50) {
                    this.logs.removeChild(this.logs.firstChild);
                }
            }
        }

        // Initialize when DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            console.log('üîê FIDO Iframe loaded');
            window.fidoHandler = new FidoIframeHandler();
        });

        // Notify parent that iframe is loaded
        window.addEventListener('load', () => {
            console.log('‚úÖ Iframe fully loaded');
        });
    </script>
</body>

</html>
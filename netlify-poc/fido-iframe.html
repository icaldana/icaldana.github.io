<!DOCTYPE html>
<html lang="pt-BR">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FIDO Authentication Iframe - Netlify</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            text-align: center;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        .iframe-container {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 30px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            max-width: 400px;
            width: 100%;
        }

        .status {
            margin: 10px 0;
            padding: 10px;
            border-radius: 5px;
            font-weight: 500;
        }

        .status.info {
            background: rgba(52, 152, 219, 0.3);
            border: 1px solid rgba(52, 152, 219, 0.5);
        }

        .status.success {
            background: rgba(46, 204, 113, 0.3);
            border: 1px solid rgba(46, 204, 113, 0.5);
        }

        .status.error {
            background: rgba(231, 76, 60, 0.3);
            border: 1px solid rgba(231, 76, 60, 0.5);
        }

        .webauthn-button {
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid white;
            color: white;
            padding: 12px 24px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 14px;
            margin: 10px;
            transition: all 0.3s ease;
        }

        .webauthn-button:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
        }

        .webauthn-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .logs {
            text-align: left;
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            margin-top: 20px;
            max-height: 200px;
            overflow-y: auto;
        }

        .log-entry {
            margin-bottom: 5px;
            opacity: 0.9;
        }

        .timestamp {
            color: #bdc3c7;
            font-size: 10px;
        }
    </style>
</head>

<body>
    <div class="iframe-container">
        <h2>üîê FIDO Authentication Service</h2>
        <p>Netlify Functions Authentication Iframe</p>

        <div id="status" class="status info">
            Aguardando solicita√ß√£o de autentica√ß√£o...
        </div>

        <button id="manual-auth" class="webauthn-button" style="display: none;">
            üîë Simular WebAuthn
        </button>

        <div id="logs" class="logs">
            <div class="log-entry">
                <span class="timestamp">[IFRAME]</span> Iframe carregado e pronto para Netlify
            </div>
        </div>
    </div>

    <script>
        // Configura√ß√£o das URLs Netlify
        const NETLIFY_CONFIG = {
            baseUrl: window.location.origin,
            authValidateUrl: '/.netlify/functions/auth-validate',
            authCloseUrl: '/.netlify/functions/auth-close'
        };

        class FidoIframeHandler {
            constructor() {
                this.port = null;
                this.logs = document.getElementById('logs');
                this.status = document.getElementById('status');
                this.manualButton = document.getElementById('manual-auth');

                this.setupMessageListener();
                this.setupManualButton();
                this.log('üîß FidoIframeHandler inicializado para Netlify');
                this.log(`üåê Netlify base URL: ${NETLIFY_CONFIG.baseUrl}`);
            }

            setupMessageListener() {
                window.addEventListener('message', (event) => {
                    this.log(`üì® Mensagem recebida de: ${event.origin}`);

                    const { message, data } = event.data;

                    if (message === 'authenticate') {
                        this.log('üöÄ Iniciando processo de autentica√ß√£o via Netlify');
                        this.handleAuthenticationRequest(data, event.ports[0]);
                    }
                });

                this.log('üëÇ Message listener configurado para Netlify');
            }

            setupManualButton() {
                this.manualButton.addEventListener('click', () => {
                    this.log('üëÜ Bot√£o manual clicado');
                    this.executeWebAuthn();
                });
            }

            async handleAuthenticationRequest(data, port) {
                this.port = port;
                this.transactionId = data.transactionId;
                this.log(`üìã Dados recebidos: ${JSON.stringify(data)}`);

                this.updateStatus('Processando solicita√ß√£o via Netlify...', 'info');

                // Notificar que estamos prontos
                this.sendMessage('ready', { timestamp: Date.now() });

                // Iniciar WebAuthn automaticamente
                this.log('üîÑ Iniciando WebAuthn via Netlify Functions...');
                this.updateStatus('Preparando autentica√ß√£o...', 'info');

                // Executar ap√≥s 1 segundo para dar tempo da UI atualizar
                setTimeout(() => {
                    this.executeWebAuthn();
                }, 1000);
            }

            async executeWebAuthn() {
                this.manualButton.style.display = 'none';
                this.log('üîê Iniciando WebAuthn...');
                this.updateStatus('Aguardando autentica√ß√£o biom√©trica...', 'info');

                try {
                    // Verificar suporte WebAuthn
                    if (!this.isWebAuthnSupported()) {
                        throw new Error('WebAuthn n√£o √© suportado neste dispositivo');
                    }

                    // Executar WebAuthn real
                    this.log('üöÄ Executando WebAuthn real...');
                    const credential = await this.tryRealWebAuthn();
                    this.log(`üîë Credencial obtida: ${credential.id}`);

                    // Validar transa√ß√£o via Netlify Function
                    this.updateStatus('Validando credencial via Netlify...', 'info');
                    this.log('üîÑ Validando com Netlify Functions...', 'info');
                    await this.validateTransaction(credential.id);

                    // Fechar transa√ß√£o e obter security token via Netlify Function
                    this.updateStatus('Fechando transa√ß√£o via Netlify...', 'info');
                    const securityToken = await this.closeTransactionAndGetToken(credential.id);
                    this.log(`üé´ Security token obtido via Netlify: ${securityToken}`);

                    // Sucesso com security token!
                    this.handleSuccess(credential, securityToken);

                } catch (error) {
                    this.log(`‚ùå Erro na autentica√ß√£o: ${error.message}`);
                    this.handleError({
                        message: error.message,
                        retriable: false,
                        cause: 'WEBAUTHN_ERROR'
                    });
                }
            }

            isWebAuthnSupported() {
                // Verifica√ß√£o REAL de suporte WebAuthn
                return 'credentials' in navigator && 'get' in navigator.credentials;
            }

            async tryRealWebAuthn() {
                try {
                    this.log('üìã Criando options para WebAuthn...');

                    // Configura√ß√£o b√°sica para WebAuthn
                    const publicKeyCredentialRequestOptions = {
                        challenge: new Uint8Array(32), // Em produ√ß√£o, viria do servidor
                        allowCredentials: [], // Permitir qualquer passkey existente
                        userVerification: 'preferred', // Preferir verifica√ß√£o biom√©trica
                        timeout: 60000, // 60 segundos
                    };

                    // Preencher challenge com dados aleat√≥rios para POC
                    crypto.getRandomValues(publicKeyCredentialRequestOptions.challenge);

                    this.log('üîê Chamando navigator.credentials.get()...');
                    this.updateStatus('üëÜ Toque no sensor biom√©trico ou use sua passkey', 'info');

                    const credential = await navigator.credentials.get({
                        publicKey: publicKeyCredentialRequestOptions
                    });

                    if (!credential) {
                        throw new Error('Nenhuma credencial retornada');
                    }

                    this.log('‚úÖ WebAuthn real bem-sucedido!');

                    // Converter para formato compat√≠vel
                    return {
                        id: credential.id,
                        type: credential.type,
                        response: {
                            authenticatorData: btoa(String.fromCharCode(...new Uint8Array(credential.response.authenticatorData))),
                            signature: btoa(String.fromCharCode(...new Uint8Array(credential.response.signature))),
                            userHandle: credential.response.userHandle ? btoa(String.fromCharCode(...new Uint8Array(credential.response.userHandle))) : null
                        }
                    };

                } catch (error) {
                    this.log(`‚ùå Erro WebAuthn real: ${error.message}`);

                    if (error.name === 'NotAllowedError') {
                        throw new Error('Usu√°rio cancelou ou n√£o autorizou a opera√ß√£o');
                    } else if (error.name === 'InvalidStateError') {
                        throw new Error('Nenhuma passkey dispon√≠vel neste dispositivo');
                    } else {
                        throw new Error(`Erro WebAuthn: ${error.message}`);
                    }
                }
            }

            async validateTransaction(credentialCode) {
                try {
                    if (!this.transactionId) {
                        throw new Error('Transaction ID n√£o encontrado');
                    }

                    this.log(`üîÑ Validando transa√ß√£o ${this.transactionId} via Netlify Function`);

                    const validateUrl = `${NETLIFY_CONFIG.authValidateUrl}/${this.transactionId}/validation`;

                    const response = await fetch(validateUrl, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            code: credentialCode
                        })
                    });

                    if (!response.ok) {
                        const errorData = await response.json().catch(() => ({}));
                        throw new Error(`Erro HTTP: ${response.status} - ${errorData.error || response.statusText}`);
                    }

                    const data = await response.json();
                    this.log(`‚úÖ Valida√ß√£o bem-sucedida via Netlify: ${JSON.stringify(data)}`, 'success');

                    return data;

                } catch (error) {
                    this.log(`‚ùå Erro na valida√ß√£o via Netlify: ${error.message}`, 'error');
                    throw new Error(`Falha na valida√ß√£o: ${error.message}`);
                }
            }

            async closeTransactionAndGetToken(transactionCode) {
                try {
                    this.log(`üé´ Fechando transa√ß√£o ${this.transactionId} via Netlify Function`);

                    const closeUrl = `${NETLIFY_CONFIG.authCloseUrl}/${this.transactionId}/close`;

                    const response = await fetch(closeUrl, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            transaction_code: transactionCode,
                            status: 'completed'
                        })
                    });

                    if (!response.ok) {
                        this.log(`‚ö†Ô∏è Erro ${response.status}, usando fallback`);
                        return transactionCode;
                    }

                    const data = await response.json();
                    this.log(`üé´ Security token obtido via Netlify: ${JSON.stringify(data)}`);

                    const securityToken = data.security_token || data.token || transactionCode;
                    this.log(`‚úÖ Token final via Netlify: ${securityToken}`);

                    return securityToken;

                } catch (error) {
                    this.log(`‚ö†Ô∏è Erro ao fechar via Netlify, usando fallback: ${error.message}`);
                    // Fallback: usar o transaction_code como security_token
                    return transactionCode;
                }
            }

            handleSuccess(credential, securityToken = null) {
                this.log('üéâ Autentica√ß√£o bem-sucedida via Netlify');
                this.updateStatus('‚úÖ Autentica√ß√£o realizada com sucesso!', 'success');

                const responseData = {
                    token: credential.id,
                    securityToken: securityToken || credential.id, // Security token obtido pelos Factors
                    sessionId: `session_${Date.now()}`,
                    credentialId: credential.id,
                    authenticatorData: credential.response.authenticatorData,
                    timestamp: new Date().toISOString(),
                    netlify: true
                };

                this.sendMessage('authenticate', responseData);
                this.log(`üì§ Resposta de sucesso enviada via Netlify com token: ${responseData.securityToken}`);
            }

            handleError(error) {
                this.log(`üí• Tratando erro: ${error.message}`);
                this.updateStatus(`‚ùå Erro: ${error.message}`, 'error');

                this.sendMessage('error', { error });
                this.log('üì§ Resposta de erro enviada');
            }

            sendMessage(message, data) {
                if (this.port) {
                    this.port.postMessage({ message, data });
                    this.log(`üì° Mensagem enviada: ${message}`);
                } else {
                    this.log('‚ö†Ô∏è Nenhuma porta dispon√≠vel para envio');
                }
            }

            updateStatus(message, type) {
                this.status.textContent = message;
                this.status.className = `status ${type}`;
                this.log(`üîÑ Status: ${message}`);
            }

            log(message) {
                const timestamp = new Date().toLocaleTimeString();
                const logEntry = document.createElement('div');
                logEntry.className = 'log-entry';
                logEntry.innerHTML = `<span class="timestamp">[${timestamp}]</span> ${message}`;

                this.logs.appendChild(logEntry);
                this.logs.scrollTop = this.logs.scrollHeight;

                // Manter apenas os √∫ltimos 50 logs
                while (this.logs.children.length > 50) {
                    this.logs.removeChild(this.logs.firstChild);
                }
            }
        }

        // Inicializar quando o DOM estiver pronto
        document.addEventListener('DOMContentLoaded', () => {
            console.log('üîê FIDO Iframe carregado para Netlify');
            window.fidoHandler = new FidoIframeHandler();
        });

        // Notificar parent que iframe est√° carregado
        window.addEventListener('load', () => {
            console.log('‚úÖ Iframe totalmente carregado para Netlify');
        });
    </script>
</body>

</html>